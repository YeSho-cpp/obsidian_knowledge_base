# 操作系统
## 操作系统(Operation System,oS)

>操作系统作为接口的示意图

<img src="https://article.biliimg.com/bfs/article/adc505a2e41f9d754d83c701b007b52db45b5a9b.png" alt="image.png" style="zoom:50%;" />

> [!note]+
> - 没有安装操作系统的计算机，通常被称为裸机
> - 如果想在裸机上运行自己所编写的程序，就必须用机器语言书写程序
> - 如果计算机上安装了操作系统，就可以在操作系统上安装支持的高级语言环境，用高级语言开发程序
> 

**操作系统的作用**
- 是现代计算机系统中**最基本和最重要**的系统软件
- 是**配置在计算机硬件上的第一层软件**，是对硬件系统的首次扩展
- 主要作用是**管理好硬件设备**，并为用户和应用程序提供一个简单的接口，以便于使用而其他的诸如编译程序、数据库管理系统，以及大量的应用软件，都直接依赖于操作系统的支持
**不同应用领域的主流操作系统**
1. 桌面操作系统
2. 服务器操作系统。
3. 嵌入式操作系统。
4. 移动设备操作系统
**桌面操作系统**
- Windows系列
	- 用户群体大
- macOS
	- 适合于开发人员
- Linux
	- 应用软件少

**服务器操作系统**
- Linux
	- 安全、稳定、免费。
	- 占有率高
- Windows Server
	- 付费
	- 占有率低
- <img src="https://article.biliimg.com/bfs/article/4766188af79b18225d962313b8388e7a0551be93.png" alt="image.png" style="zoom:50%;" />
- 嵌入式操作系统
	- Linux
- 移动设备操作系统  
	- ios
	- Android(基于`Linux`)


**虚拟机**
虚拟机(Virtual Machine)指通过<font color=#ff0000>软件模拟的具有完整</font>硬件系统功能的、运行在一个==完全隔离环境==中的完整计算机系统
- 虚拟系统通过生成现有操作系统的全新虚拟镜像，具有真实操作系统完全一样的功能
- 进入虚拟系统后，所有操作都是在这个全新的独立的虚拟系统里面进行，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响
- 而且能够在现有系统与虚拟镜像之间灵活切换的一类操作系统

## 操作系统的发展史

Unix和Minix历史省略
### Linux内核及发行版
#### Linux内核版本
- **内核(kernel)** 是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的<font color=#ff0000>核心程序</font>，它提供了一个在<font color=#ff0000>裸设备与应用程序间的抽象层</font>
- Linux内核版本又分为**稳定版**和**开发版**，两种版本是相互关联，相互循环
- 稳定版:具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些bug或加入一些新的驱动程序
- 开发版:由于要试验各种解决方案，所以变化很快
- 内核源码网址: http://www.kernel.org

> [!note]+
所有来自全世界的对Linux源码的修改最终都会汇总到这个网站，由Linus领导的开源社区对其进行甄别和修改最终决定是否进入到Linux主线内核源码中

#### Linux发行版本
- **Linux发行版（也被叫做GNULinux 发行版)** 通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件
- 常见的发行版本如下:
	- `Ubuntu`
	- `Redhat`
	- `Fedorao`
	- `openSuSE`
	- `Linux Mint`
	- `Debian`
	- `Manjaro`
	- `Mageia`
	- `Centos`

> [!note]+
在几乎每一份与Linux有关的榜单上，基于Debian的Ubuntu都占有一席之位。Canonical的Ubuntu胜过其他所有的Linux服务器发行版――从简单安装、出色的硬件发现，到世界级的商业支持，Ubuntu确立了难以企及的严格标准

#### Linux的应用领域

**服务器领域**
- Linux在服务器领域的应用是其重要分支
- Linux免费、稳定、高效等特点在这里得到了很好的体现
	- 早期因为维护、运行等原因同样受到了很大的限制
	- 近些年来Linux服务器市场得到了飞速的提升，尤其在一些高端领域尤为广泛
**嵌入式领域**
- 近些年来Linux在嵌入式领域的应用得到了飞速的提高
- Linux运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达到几百KB等特点，使其近些年来在嵌入式领域的应用得到非常大的提高
> [!note]+
主要应用:机顶盒、数字电视、网络电话、程控交换机、手机、PDA、等都是其应用领域，得到了Google、三星、摩托罗拉、NEC等公司的大力推广

# 文件和目录
## 单用户操作系统和多用户操作系统（科普)
- **单用户操作系统**:指一台计算机在同一时间**只能由一个用户**使用，一个用户独自享用系统的全部硬件和软件资源
	- Windows XP之前的版本都是单用户操作系统
- **多用户操作系统**:指一台计算机在同一时间可以**由多个用户使用**，多个用户共同享用系统的全部硬件和软件资源
	- Unix和Linux的设计初衷就是多用户操作系统
## windows和Linux文件系统区别
**windows下的文件系统**
- 在windows下，打开“计算机”，我们看到的是一个个的驱动器盘符:
	- <img src="https://article.biliimg.com/bfs/article/afd1249eb5c847aef45413ef666c8fc06b27d0e5.png" alt="image.png" style="zoom:50%;" />
- 每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形，如图所示:
	- <img src="https://article.biliimg.com/bfs/article/6c28b0fe97ce176d9a94e7b5a017cfc54dec1493.png" alt="image.png" style="zoom:50%;" />

## Linux下的文件系统
- 在`Linux`下，我们是看不到这些驱动器盘符，我们看到的是文件夹(目录)︰
	- <img src="https://article.biliimg.com/bfs/article/18f178a8e1e1607dcc83fac63947101a4ed1c570.png" alt="image.png" style="zoom:50%;" />
- ubuntu没有盘符这个概念，只有一个根目录/，所有文件都在它下面
	- ![image.png](https://article.biliimg.com/bfs/article/bd95892575a83890b5aa9680ae6e81351627e930.png)

用户目录
位于`/home/user`，称之为用户工作目录或家目录，表示方式:

```bash
/home/user
~
```

## Linux主要目录速查表

- `/`∶根目录，**一般根目录下只存放目录**，在linux下有且只有一个根目录，所有的东西都是从这里开始
- 当在终端里输入`/home`，其实是在告诉电脑，先从`/`(根目录)开始，再进入到`home`目录
- `/bin、/usr/bin`:可执行二进制文件的目录，如常用的命令`ls、tar、mv、cat`等
- `/boot`:放置linux系统启动时用到的一些文件，如linux的内核文件: `/boot/vmlinuz`，系统引导管理器: `/boot/grub`
- `/dev`:存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱`mount/dev/cdrom/mnt`
- `/etc`:**系统配置**文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有
	- `/etc/inittab`
	- `/etc/fstab`
	- `/etc/init.d`
	- `/etc/X11`
	- `/etc/sysconfig`
	- `/etc/xinetd.d`
- `/home`:系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下
	- `~`表示当前用户的家目录
	- `~edu`表示用户`edu`的家目录
- `/lib`、`/usrllib`、`/usr/local/lib`:系统使用的**函数库**的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助
- `/lost+fount`:系统异常产生错误时，会将一些遗失的片段放置于此目录下
- `/mnt`: `/media`:光盘默认挂载点，通常光盘挂载于`/mnt/cdrom` 下，也不一定，可以选择任意位置进行挂载
- `/opt`:给主**机额外安装软件**所摆放的目录
- `/proc`:此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的文件
	- 有:`/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net`/`*`等
- `/root`:系统管理员root的家目录
- `/sbin、/usr/sbin、/usr/loca/sbin`:放置系统管理员使用的可执行命令，如`fdisk、shutdown、mount`等。与`/bin`不同的是，这几个目录是给系统管理员root使用的命令，一般用户只能"查看"而不能设置和使用
- `/tmp`:一般用户或正在执行的**程序临时存放文件**的目录，任何人都可以访问，重要数据不可放置在此目录下
- `/srv`:服务启动之后需要访问的数据目录，如www服务需要访问的网页数据存放在`/srv/www` 内
- `/usr`:应用程序存放目录
	- `/usr/bin`:存放应用程序o/usrlshare:存放共享数据
	- `/usr/lib`:存放不能直接运行的，却是许多程序运行所必需的一些函数库文件
	- `/usr/local`:存放软件升级包
	- `/usr/shareldoc`:系统说明文件存放目录
	- `/usr/share/man`:程序说明文件存放目录.
- `/var`:放置系统执行过程中**经常变化**的文件
	- `/var/log`:随时更改的日志文件
	- `/var/spool/mail`:邮件存放的目录
	- `/var/run`:程序或服务启动后，其PID存放在该目录下

# 常用Linux命令的基本使用
## 学习Linux终端命令的原因

Linux刚面世时并没有图形界面，所有的操作全靠命令完成，如<font color=#ff0000>磁盘操作、文件存取、目录操作、进程管理、文件权限</font>设定等
在职场中，大量的服务器维护工作都是<font color=#ff0000>在远程通过SSH客户端来完成</font>的，并没有图形界面，所有的维护工作都需要通过命令来完成
在职场中，作为后端程序员，必须要或多或少的掌握一些Linux常用的终端命令
Linux发行版本的命令大概有200多个，但是常用的命令只有10多个而已

> [!note]+  学习终端命令的技巧
> - 不需要死记硬背，对于常用命令，用的多了，自然就记住了
> - 不要尝试一次学会所有的命令，有些命令是非常不常用的，临时遇到，临时百度就可以


## 常用Linux命令的基本使用

|序号| 命令 |对应英文| 作用 |
|:-:|:-:|:-:|:-:|
| 01 | `ls` | `list` | 查看当前文件夹下的内容 |
| 02 | `pwd` | `print work directory` | 查看当前所在文件夹 |
| 03 | `cd [目录名]` | `change directory` | 切换文件夹 |
| 04 | `touch [文件名]` | `touch` | 如果文件不存在，新建文件 |
| 05 | `mkdir [目录名]` | `make directory` | 创建目录 |
| 06 | `rm [文件名]` | `remove` | 删除指定的文件名 |
| 07 | `clear` | `clear` | 清屏 |

> [!note]+ 小技巧
> - ctrl + shift +=放大终端窗口的字体显示。 
> - ctrl +-缩小终端窗口的字体显示


## 自动补全
- 在敲出`文件/目录/命令`的前几个字母之后，按下`tab`键
	- 如果输入的没有歧义，系统会自动补全
	- 如果还存在其他`文件/目录/命令`，再按一下`tab`键，系统会提示可能存在的命令

> [!note]+ 小技巧
> - 按上/下光标键可以在曾经使用过的命令之间来回切换
> - 如果想要退出选择，并且不想执行当前选中的命令，可以按`ctrl + c`

## Linux终端命令格式
### 终端命令格式
```powershell
command [-options][parameter]
```
说明:
- `command` :命令名，相应功能的英文单词或单词的缩写
- `[-options]` :选项，可用来对命令进行控制，也可以省略
- `parameter` :传给命令的参数，可以是零个、一个或者多个

> `[]`代表可选


### 02.查阅命令帮助信息(知道)

> [!note]+ 提示
> - 现阶段只需要知道通过以下两种方式可以查询命令的帮助信息
> - 先学习常用命令及常用选项的使用即可，工作中如果遇到问题可以借助网络搜索

`--help`
command --help
说明:
显示command 命令的帮助信息
说明:
查阅command命令的使用手册

`man`

```powershell
man command
```
说明
- 查阅command命令的使用手册
> `man`是manual的缩写，是Linux提供的一个手册，包含了绝大部分的命令、函数的详细使用说明


**使用man时的操作键:**

|操作键| 功能 |
|:-:|:-:|
| 空格键 | 显示手册页的下一屏 |
| Enter 键 | 一次滚动手册页的一行 |
| b | 回滚一屏 |
| f | 前滚一屏 |
| q | 退出 |
|/word| 搜索word字符串 |
## 文件和目录常用命令

### 查看目录内容
#### 终端实用技巧
**曾经使用过的命令**
- 按`上/下`光标键可以在==曾经使用过==的命令之间来回切换
- 如果想要退出选择，并且不想执行当前选中的命令，可以按`ctrl + `c
**`1s` 命令说明**
- `ls` 是英文单词list的简写，其功能为列出目录的内容，是用户最常用的命令之一，类似于DOS下的`dir`命令
### Linux下文件和目录的特点
- Linux**文件**或者**目录**名称最长可以有256个字符
- 以`﹒`开头的文件为隐藏文件，需要用`-a`参数才能显示· 
- `.`代表当前目录
- `..`代表上—级目录

### ls常用选项

|参数 |含义|
|:-:|:-:|
|`-a`| 显示指定目录下所有子目录与文件，包括隐藏文件 |
|`-l`| 以列表方式显示文件的详细信息               |
|`-h`| 配合-l以人性化的方式显示文件大小            |

### ls通配符的使用

|通配符|含义|
|:-:|:-:|
|`*`| 代表任意个数个字符            |
|`?`| 代表任意一个字符，至少1个     |
|`[0-9]`| 表示可以匹配数字0到9中的任意一个 |
|`[abc]`| 匹配a、b、c中的任意一个       |
|`[a-f]`| 匹配从a到f范围内的任意一个字符 |


# Linux库

- 不管是Linux还是Windows中的库文件其本质和工作模式都是相同的, 只不过在不同的平台上库对应的文件格式和文件后缀不同。程序中调用的库有两种 `静态库`和`动态库`，不管是哪种库文件本质是还是源文件，只不过是二进制格式只有计算机能够识别，作为一个普通人就无能为力了。
- 在项目中使用库一般有两个目的，一个是为了使程序更加简洁不需要在项目中维护太多的源文件，另一方面是为了源代码保密，毕竟不是所有人都想把自己编写的程序开源出来。
- 当我们拿到了库文件（动态库、静态库）之后要想使用还必须有这些库中提供的API函数的声明，也就是头文件，把这些都添加到项目中，就可以快乐的写代码了。

## 静态库

> 在Linux中静态库由程序 `ar` 生成，现在静态库已经不像之前那么普遍了，这主要是由于程序都在使用动态库。关于静态库的命名规则如下:

- 在Linux中静态库以`lib`作为前缀, 以`.a`作为后缀, 中间是库的名字自己指定即可, 即: `libxxx.a`
- 在Windows中静态库一般以lib作为前缀, 以lib作为后缀, 中间是库的名字需要自己指定, 即: `libxxx.lib`
## 生成静态链接库
生成静态库，需要先对源文件进行汇编操作 (`使用参数 -c)` 得到二进制格式的目标文件 (`.o 格式`), 然后在通过`ar`工具将目标文件打包就可以得到静态库文件了 (`libxxx.a`)。

使用ar工具创建静态库的时候需要三个参数:

- `参数c`：创建一个库，不管库是否存在，都将创建。
- `参数s`：创建目标文件索引，这在创建较大的库时能加快时间。
- `参数r`：在库中插入模块(替换)。默认新的成员添加在库的结尾处，如果模块名已经在库中存在，则替换同名的模块。

<img src="https://subingwen.cn/linux/library/static-lib.png" alt="image.png" style="zoom:100%;" />

生成静态链接库的具体步骤如下:

1. 需要将源文件进行汇编, 得到`.o`文件, 需要使用参数 -c

	```shell
	# 执行如下操作, 默认生成二进制的 .o 文件
	# -c 参数位置没有要求
	$ gcc 源文件(*.c) -c	
	```

2. 将得到的 .o 进行打包, 得到静态库

	```shell
	$ ar rcs 静态库的名字(libxxx.a) 原材料(*.o)
	```

3. 发布静态库

	```shell
	# 发布静态库
		1. 提供头文件 **.h
		2. 提供制作出来的静态库 libxxx.a
	```

### 静态库制作举例
#### 准备测试程序
> 在某个目录中有如下的源文件, 用来实现一个简单的计算器:

```shell
# 目录结构 add.c div.c mult.c sub.c -> 算法的源文件, 函数声明在头文件 head.h
# main.c中是对接口的测试程序, 制作库的时候不需要将 main.c 算进去
.
├── add.c
├── div.c
├── include
│   └── head.h
├── main.c
├── mult.c
└── sub.c
```


#### 生成静态库
第一步: 将源文件`add.c, div.c, mult.c, sub.c` 进行汇编, 得到二进制目标文件 `add.o, div.o, mult.o, sub.o`

```shell
# 1. 生成.o
$ gcc add.c div.c mult.c sub.c -c
sub.c:2:18: fatal error: head.h: No such file or directory
compilation terminated.

# 提示头文件找不到, 添加参数 -I 重新头文件路径即可
$ gcc add.c div.c mult.c sub.c -c -I ./include/

# 查看目标文件是否已经生成
$ tree
.
├── add.c
├── add.o            # 目标文件
├── div.c
├── div.o            # 目标文件
├── include
│   └── head.h
├── main.c
├── mult.c
├── mult.o           # 目标文件
├── sub.c
└── sub.o            # 目标文件
```

> 第二步: 将生成的目标文件通过` ar`工具打包生成静态库

```shell
# 2. 将生成的目标文件 .o 打包成静态库
$ ar rcs libcalc.a a.o b.o c.o    # a.o b.o c.o在同一个目录中可以写成 *.o

# 查看目录中的文件
$ tree
.
├── add.c
├── add.o
├── div.c
├── div.o
├── include
│   └── `head.h  ===> 和静态库一并发布
├── `libcalc.a   ===> 生成的静态库
├── main.c
├── mult.c
├── mult.o
├── sub.c
└── sub.o
```

> 第三步: 将生成的的静态库 `libcalc.a`和库对应的头文件`head.h`一并发布给使用者就可以了。

```shell
# 3. 发布静态库
	1. head.h    => 函数声明
	2. libcalc.a => 函数定义(二进制格式)
```


### 静态库的使用
> 当我们得到了一个可用的静态库之后, 需要将其放到一个目录中, 然后根据得到的头文件编写测试代码, 对静态库中的函数进行调用。

```shell
# 1. 首先拿到了发布的静态库
	`head.h` 和 `libcalc.a`
	
# 2. 将静态库, 头文件, 测试程序放到一个目录中准备进行测试
.
├── head.h          # 函数声明
├── libcalc.a       # 函数定义（二进制格式）
└── main.c          # 函数测试
```


> [!attention] 注意
> 编译的源文件中包含了头文件` head.h`, 这个头文件中声明的函数对应的定义（也就是函数体实现）在静态库中，程序在编译的时候没有找到函数实现，因此提示 `undefined reference to xxxx`。
> 解决方案：在编译的时将`静态库`的路径和`名字`都指定出来
> - `-L`: 指定库所在的目录(相对或者绝对路径)
> - `-l`: 指定库的名字, 需要掐头(lib)去尾(.a) 剩下的才是需要的静态库的名字。

```shell
# 4. 编译的时候指定库信息
	-L: 指定库所在的目录(相对或者绝对路径)
	-l: 指定库的名字, 掐头(lib)去尾(.a) ==> calc
# -L -l, 参数和参数值之间可以有空格, 也可以没有  -L./ -lcalc
$ gcc main.c -o app -L ./ -l calc

# 查看目录信息, 发现可执行程序已经生成了
$ tree
.
├── app   		# 生成的可执行程序
├── head.h
├── libcalc.a
└── main.c
```

## 动态库

> 动态链接库是程序运行时加载的库，当动态链接库正确部署之后，运行的多个程序可以使用同一个加载到内存中的动态库，因此在Linux中动态链接库也可称之为共享库。
> 动态链接库是目标文件的集合，目标文件在动态链接库中的组织方式是按照特殊方式形成的。库中函数和变量的地址使用的是相对地址（静态库中使用的是绝对地址），其真实地址是在应用程序加载动态库时形成的。
> 关于动态库的命名规则如下:


- 在Linux中动态库以`lib`作为前缀, 以`.so`作为后缀, 中间是库的名字自己指定即可, 即: `libxxx.so`
- 在Windows中动态库一般以`lib`作为前缀, 以`dll`作为后缀, 中间是库的名字需要自己指定, 即: `libxxx.dll`

### 生成动态链接库
生成动态链接库是直接使用`gcc`命令并且需要添加`-fPIC（-fpic）` 以及`-shared` 参数。

- `-fPIC` 或 `-fpic` 参数的作用是<font color=#ff0000>使得 gcc 生成的代码是与位置无关的，也就是使用相对位置</font>。
- `-shared`参数的作用是告诉编译器生成一个动态链接库。

<img src="https://subingwen.cn/linux/library/dll-0.png" alt="image.png" style="zoom:90%;" />

生成动态链接库的具体步骤如下:

1. 将源文件进行汇编操作, 需要使用参数 -c, 还需要添加额外参数 -fpic / -fPIC

	```shell
	# 得到若干个 .o文件
	$ gcc 源文件(*.c) -c -fpic
	```
2. 将得到的.o文件打包成动态库, 还是使用gcc, 使用参数 -shared 指定生成动态库(位置没有要求)

	```shell
	$ gcc -shared 与位置无关的目标文件(*.o) -o 动态库(libxxx.so)
	```
3. 发布动态库和头文件
```shell
# 发布
 	1. 提供头文件: xxx.h
 	2. 提供动态库: libxxx.so
```

### 动态库制作举例
在此还是以上面制作静态库使用的实例代码为例来制作动态库, 代码目录如下:

> 第一步: 使用`gcc`将源文件进行汇编(`参数-c`), 生成与位置无关的目标文件, 需要使用参数 `-fpic或者-fPIC`

```shell
# 1. 将.c汇编得到.o, 需要额外的参数 -fpic/-fPIC
$ gcc add.c div.c mult.c sub.c -c -fpic -I ./include/

# 查看目录文件信息, 检查是否生成了目标文件
$ tree
.
├── add.c
├── add.o                # 生成的目标文件
├── div.c
├── div.o                # 生成的目标文件
├── include
│   └── head.h
├── main.c
├── mult.c
├── mult.o               # 生成的目标文件
├── sub.c
└── sub.o                # 生成的目标文件
```

> 第二步: 使用gcc将得到的目标文件打包生成动态库, 需要使用参数 `-shared`

```shell
# 2. 将得到 .o 打包成动态库, 使用gcc , 参数 -shared
$ gcc -shared add.o div.o mult.o sub.o -o libcalc.so  

# 检查目录中是否生成了动态库
$ tree
.
├── add.c
├── add.o
├── div.c
├── div.o
├── include
│   └── `head.h   ===> 和动态库一起发布
├── `libcalc.so   ===> 生成的动态库
├── main.c
├── mult.c
├── mult.o
├── sub.c
└── sub.o
```

> 第三步: 发布生成的动态库和相关的头文件

```shell
# 3. 发布库文件和头文件
	1. head.h
	2. libcalc.so
```


### 动态库的使用
> 当我们得到了一个可用的动态库之后, 需要将其放到一个目录中, 然后根据得到的头文件编写测试代码, 对动态库中的函数进行调用。


```shell
# 1. 拿到发布的动态库
	`head.h   libcalc.so
# 2. 基于头文件编写测试程序, 测试动态库中提供的接口是否可用
	`main.c`
# 示例目录:
.
├── head.h          ==> 函数声明
├── libcalc.so      ==> 函数定义
└── main.c          ==> 函数测试
```

> 编译测试程序



添加库信息相关参数, 重新编译测试代码:

```shell
# 在编译的时候指定动态库相关的信息: 库的路径 -L, 库的名字 -l
$ gcc main.c -o app -L./ -lcalc

# 查看是否生成了可执行程序
$ tree
.
├── app 			# 生成的可执行程序
├── head.h
├── libcalc.so
└── main.c

# 执行生成的可执行程序, 错误提示 ==> 可执行程序执行的时候找不到动态库
$ ./app 
./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory
```

> [!bug]
> 关于整个操作过程的报告：    
> ​gcc通过指定的动态库信息生成了可执行程序, 但是可执行程序运行却提示`无法加载到动态库`。



### 解决动态库无法加载问题
#### 库的工作原理

- 静态库如何被加载

	在程序编译的最后一个阶段也就是链接阶段，提供的静态库会被打包到可执行程序中。当可执行程序被执行，静态库中的代码也会一并被加载到内存中，因此不会出现静态库找不到无法被加载的问题。
- 动态库如何被加载
	- 在程序编译的最后一个阶段也就是链接阶段：
		- 在gcc命令中虽然指定了库路径(`使用参数 -L` ), 但是这个路径并没有记录到可执行程序中，只是检查了这个路径下的库文件是否存在。
		- 同样对应的动态库文件也没有被打包到可执行程序中，只是在可执行程序中记录了库的名字。
- 可执行程序被执行起来之后:
	- 程序执行的时候会`先检测`需要的动态库是否可以被加载，加载不到就会提示上边的错误信息
	- <font color=#ff0000>当动态库中的函数在程序中被调用了, 这个时候动态库才加载到内存，如果不被调用就不加载</font>
	- 动态库的检测和内存加载操作都是由动态连接器来完成的
#### 动态链接器

> 动态链接器是一个独立于应用程序的进程, 属于操作系统, 当用户的程序需要加载动态库的时候动态连接器就开始工作了，很显然动态连接器根本就不知道用户通过 gcc 编译程序的时候通过参数 `-L`指定的路径。
> 
> 那么动态链接器是如何搜索某一个动态库的呢，在它内部有一个默认的搜索顺序，按照优先级从高到低的顺序分别是：

1. 可执行文件内部的 DT_RPATH 段
2. 系统的环境变量 LD_LIBRARY_PATH
3. 系统动态库的缓存文件 /etc/ld.so.cache
4. 存储动态库/静态库的系统目录 /lib/, /usr/lib等
按照以上四个顺序, 依次搜索, 找到之后结束遍历, 最终还是没找到, 动态连接器就会提示动态库找不到的错误信息。

#### 解决方案

> 可执行程序生成之后, 根据动态链接器的搜索路径, 我们可以提供三种解决方案，我们只需要将动态库的路径放到对应的环境变量或者系统配置文件中，同样也可以将动态库拷贝到系统库目录（或者是将动态库的软链接文件放到这些系统库目录中）。

- 方案1: 将库路径添加到环境变量 `LD_LIBRARY_PATH` 中
	
	1. 找到相关的配置文件
		- `用户级别`: ~/.bashrc` —> 设置对当前用户有效
		- `系统级别: /etc/profile` —> 设置对所有用户有效`
	
	2. 使用 vim 打开配置文件, 在文件最后添加这样一句话
	
		```shell
		# 自己把路径写进去就行了
		export LIBRARY_PATH=$LIBRARY_PATH:动态库的绝对路径
		```
	
	3. 让修改的配置文件生效
		- 修改了用户级别的配置文件, 关闭当前终端, 打开一个新的终端配置就生效了
		- 修改了系统级别的配置文件, 注销或关闭系统, 再开机配置就生效了
		- 不想执行上边的操作, 可以执行一个命令让配置重新被加载
	
	```shell
	# 修改的是哪一个就执行对应的那个命令
	# source 可以简写为一个 . , 作用是让文件内容被重新加载
	$ source ~/.bashrc          (. ~/.bashrc)
	$ source /etc/profile       (. /etc/profile)
```

- 方案2: 更新 `/etc/ld.so.cache` 文件

	1. 找到动态库所在的绝对路径（不包括库的名字）比如：`/home/robin/Library/`
	2. 使用vim 修改 `/etc/ld.so.conf` 这个文件, 将上边的路径添加到文件中(独自占一行)
	
		```shell
		# 1. 打开文件
		$ sudo vim /etc/ld.so.conf
		
		# 2. 添加动态库路径, 并保存退出
		```
	
	3. 更新 `/etc/ld.so.conf`中的数据到 `/etc/ld.so.cache` 中
	
		```shell
		# 必须使用管理员权限执行这个命令
		$ sudo ldconfig
		```   

- 方案3: 拷贝动态库文件到系统库目录 `/lib/` 或者 `/usr/lib` 中 (或者将库的软链接文件放进去)
```shell
# 库拷贝
sudo cp /xxx/xxx/libxxx.so /usr/lib

# 创建软连接
sudo ln -s /xxx/xxx/libxxx.so /usr/lib/libxxx.so
```

#### 验证
> 在启动可执行程序之前, 或者在设置了动态库路径之后, 我们可以通过一个命令检测程序能不能够通过动态链接器加载到对应的动态库, 这个命令叫做 `ldd`

```shell
# 语法:
$ ldd 可执行程序名

# 举例:
$ ldd app
	linux-vdso.so.1 =>  (0x00007ffe8fbd6000)
    libcalc.so => /home/robin/Linux/3Day/calc/test/libcalc.so (0x00007f5d85dd4000)
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5d85a0a000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f5d85fd6000)  ==> 动态链接器, 操作系统提供
```

## 优缺点

### 静态库
- 优点：
	- 静态库被打包到应用程序中加载速度快
	- 发布程序无需提供静态库，移植方便
- 缺点：
	- 相同的库文件数据可能在内存中被加载多份, 消耗系统资源，浪费内存
	- 库文件更新需要重新编译项目文件, 生成新的可执行程序, 浪费时间。

	<img src="https://subingwen.cn/linux/library/dll-1.png" alt="image.png" style="zoom:90%;" />

### 动态库
- 优点：
	- 可实现不同进程间的资源共享
	- 动态库升级简单, 只需要替换库文件, 无需重新编译应用程序
	- 程序猿可以控制何时加载动态库, 不调用库函数动态库不会被加载
- 缺点：
	- 加载速度比静态库慢, 以现在计算机的性能可以忽略
	- 发布程序需要提供依赖的动态库

<img src="https://subingwen.cn/linux/library/dll-2.png" alt="image.png" style="zoom:90%;" />


# core dump

[Linux内核调试方法总结之coredump - 知乎](https://zhuanlan.zhihu.com/p/514516021)

[什么是 core dump ? 以及如何使用gdb对 core dumped 进行调试-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1353705)



这个项目要怎么介绍？
1. 如果面试管问，我看你做的webserver